# YModules на пальцах

## Что такое модули?

`YModules` представляет собой инструмент веб-разработчика - модульную систему, удобную для использования в связке с методологией БЭМ.

После того, как клиентский JavaScript-код блоков вашего сайта уже написан, можно разместить код отдельных компонентов по контейнерам, которые называются `модулями`.

Модуль подобен фантику от конфеты, на котором написано её название и который является лишь обёрткой. Система модулей, в свою очередь, напоминает корзинку с разными сладостями, из которой удобно доставать приглянувшиеся конфеты, определяя нужную по фантику.

## Зачем использовать модули?

Вспомним, как обычно связываются между собой различные компоненты.

Для этого рассмотрим пример: объявим на странице блок с формой авторизации и напишем для неё клиентский JavaScript-код. В нём опишем поведение формы: после нажатия на кнопку `Submit` авторизационные данные отправляются с помощью Ajax, а не через стандартный `form.submit()`.

Допустим, в проекте уже определён специальный компонент `Кнопка`, в котором реализовано всё поведение кнопки. Поведение может быть следующим: *по клику совершается действие, определяемое компонентом, из которого кнопка была вызвана*. Таким образом, форма авторизации должна суметь найти кнопку, вызвать её и слушать на ней событие клика.

Но как определить, что компонент готов взаимодействовать с другими блоками?

Модульная система отслеживает готовность всех компонентов за вас. Она также избавляет от необходимости вручную поддерживать зависимости между сущностями в актуальном виде. Функция модуля - объявлять о том, что ему для корректной работы нужен конкретный компонент. Это сходно с реализацией процесса наследования, при котором в коде компонента явно указывается его родительский класс.

При оформлении формы, к примеру, в виде ymaps-модуля, в нём можно задекларировать зависимость от кнопки. При этом, код формы будет активирован только тогда, когда всё для этого будет готово. В частности, когда кнопка будет готова слушать событие клика на себе.

## Как использовать модули?

Напишем для примера код модуля. Для начала объявим модуль с помощью метода `define()` и назовём его `A`:

````javascript
modules.define(
    'A'
);
````

Уточним, что наш модуль зависит от модулей `B` и `C`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
);
````

Опишем код модуля в анонимной функции. Код модулей `B` и `C` придёт в эту функцию в виде параметров, которые можно будет использовать внутри нашего `A`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

    }
);
````

С помощью метода `provide(a)` разрешим, в свою очередь, другим модулям использовать `A`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

        provide(a);
    }
);
````

Модуль `A` определён, и теперь мы можем поместить внутрь этой обёртки начинку – новый компонент `var a = {}`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = 'Candies are awesome';

        provide(a);
    }
);
````

Другой виртуальный пример – код модуля, отвечающего за форму логина:

````javascript
modules.define(
    'y-form',
    ['y-button'],
    function(provide, button) {
        //помещаем код компонента внутрь модуля:
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(button).css('disabled')) {
                return false;
            }
            form.submit();
        }
        //конец кода компонента

        provide(form);
    }
);
````

Здесь, в теле анонимной функции, мы программируем поведение формы в зависимости от того, активна кнопка или нет. Используя метод `define()`, мы определяем сам модуль с анонимной функцией внутри. Используя метод `provide()`, мы заявляем, что данный модуль может быть вызван другими.

Модули – независимы и запускаются лишь в случае, если все их зависимости зарезолвлены. Резолвятся они асинхронно, и дерево зависимостей строится в рантайме. Модули можно переопределять и доопределять в любой момент.

Дерево зависимостей модульной системы также можно и удобно использовать в любом файловом сборщике: имя модуля легко мапится на имя файла, в котором этот модуль хранится.
