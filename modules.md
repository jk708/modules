# Что из себя представляют модули?

После того, как клиентский JavaScript-код вашего сайта написан, рационально поместить содержимое некоторых его участков в отдельные контейнеры - модули. Модуль подобен фантику от конфеты, на котором написано её название и который является лишь удобной обёрткой.

Система модулей, в свою очередь, напоминает корзинку сладостей, из которой удобно доставать приглянувшиеся в данный момент конфеты.

# Зачем использовать модули?

Рассмотрим пример: объявим на странице блок с формой авторизации и напишем для неё клиентский JavaScript-код. В нём опишем поведение формы: после нажатия на кнопку `Submit` авторизационные данные отправляются с помощью Ajax, а не через стандартный `form.submit()`.

Допустим, в проекте уже определен специальный компонент `Кнопка`, в котором реализовано всё поведение кнопки. Поведение может быть следующим: *по клику должно совершиться какое-либо действие, определяемое компонентом, из которого кнопка была вызвана*. В этом случае форма авторизации должна суметь найти кнопку, вызвать её и слушать на ней событие клика.

Как определить, что компонент готов взаимодействовать с другими блоками?

Модульная система позволяет избежать необходимости отслеживать и поддерживать зависимости между сущностями вручную. Сходно процессу наследования, при котором явно не указываются классы родителей, зависимости в подобной системе описаны в коде оболочек - не в коде компонентов.

При оформлении формы в виде ymaps-модуля, в нём можно задекларировать зависимость от кнопки. При этом, код формы будет активирован только тогда, когда для этого всё будет готово. В частности, когда кнопка будет готова слушать событие клика. В этом случае модульная система отследит готовность всех компонентов за вас.

# Как использовать модули?

Напишем для примера код модуля. Для начала объявим модуль с помощью метода `define()` и назовём его `A`:

````javascript
modules.define(
    `A`
);
````

Задекларируем его зависимость от модулей `B` и `C`:

````javascript
modules.define(
    'A',
    ['B', 'C'],
);
````

Опишем код модуля в анонимной функции. Код `B` и `C` придёт в функцию в виде параметров, которые можно будет использовать внутри нашего модуля:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

    }
);
````

С помощью метода `provide(a) разрешим, в свою очередь, другим модулям использовать наш:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
````

И, после всех сложностей, наконец-то поместим внутрь обёртки начинку - определим новый компонент:

````javascript
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = 'Candies are awesome';

        provide(a);
    }
);
````

Другой виртуальный пример - код модуля, отвечающий за форму логина:

````javascript
modules.define(
    'y-form',
    ['y-button'],
    function(provide, button) {
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(button).css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
````

Здесь, в теле анонимной функции, мы программируем поведение формы в зависимости от того, активна кнопка или нет. Используя метод `define()`, мы определяем модуль с анонимной функцией внутри. Используя метод `provide()`, мы заявляем, что данный модуль может быть вызван другими.

Модули - независимы и запускаются лишь в случае, если все их зависимости зарезолвлены. Резолвятся они асинхронно, и дерево зависимостей строится в рантайме. Модули можно переопределять и доопределять в любой момент.

Дерево зависимостей модульной системы также можно и удобно использовать в любом файловом сборщике.
